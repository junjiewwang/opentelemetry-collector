# Custom OpenTelemetry Collector Configuration
# This configuration demonstrates the Agent Gateway receiver with unified capabilities.
# Architecture: storageext -> controlplaneext/adminext -> arthastunnelext (optional)

receivers:
  # Agent Gateway Receiver - Unified gateway for all agent communication
  # Supports: OTLP, Control Plane APIs, Arthas Tunnel (WebSocket)
  # 
  # This receiver replaces enhanced_otlp and provides:
  # - OTLP HTTP/gRPC for traces, metrics, logs
  # - Control Plane APIs for agent management
  # - Arthas Tunnel for remote debugging (optional)
  # - Token-based authentication with middleware
  agent_gateway:
    # HTTP server configuration (required)
    http:
      endpoint: 0.0.0.0:4318
      # Optional: TLS configuration
      # tls:
      #   cert_file: /path/to/cert.pem
      #   key_file: /path/to/key.pem
    
    # gRPC server configuration (optional, for OTLP gRPC)
    grpc:
      endpoint: 0.0.0.0:4317
    
    # OTLP configuration
    otlp:
      enabled: true
      traces_path: /v1/traces
      metrics_path: /v1/metrics
      logs_path: /v1/logs
    
    # Control Plane configuration
    # Available endpoints:
    #   - GET/POST /v1/control/config   - Configuration management
    #   - GET/POST /v1/control/tasks    - Task management
    #   - GET/POST /v1/control/status   - Status reporting
    #   - POST /v1/control/register     - Agent registration
    #   - POST /v1/control/unregister   - Agent unregistration
    #   - GET /v1/control/agents        - List agents
    #   - POST /v1/control/upload-chunk - Chunk upload
    #   - GET /health                   - Health check
    control_plane:
      enabled: true
      path_prefix: /v1/control
    
    # Arthas Tunnel configuration (for remote Java debugging)
    # Requires arthastunnelext extension to be configured
    arthas_tunnel:
      enabled: true
      path: /v1/arthas/ws
    
    # Token authentication configuration
    # Uses middleware for cleaner separation of concerns
    token_auth:
      enabled: true
      header_name: "Authorization"
      header_prefix: "Bearer "
      # Paths that skip authentication
      skip_paths:
        - /health
      # Inject validated app_id into resource attributes
      # This allows downstream processors to access the app_id
      inject_attribute_key: "app_id"

  # [DEPRECATED] Enhanced OTLP receiver - Use agent_gateway instead
  # Kept for backward compatibility, will be removed in future versions
  # enhanced_otlp:
  #   protocols:
  #     grpc:
  #       endpoint: 0.0.0.0:4317
  #     http:
  #       endpoint: 0.0.0.0:4318
  #   control_plane:
  #     enabled: true
  #   token_auth:
  #     enabled: true
  #     header_name: "Authorization"
  #     header_prefix: "Bearer "
  #     inject_attribute_key: "token"

extensions:
  # Storage extension - provides Redis and Nacos client management
  # Other extensions reference this by name to reuse storage connections
  storage:
    # Redis connections (supports Standalone/Cluster/Sentinel modes)
    redis:
      default:
        # Standalone mode
        addr: "[[.Service.redis_apm.host]]:[[.Service.redis_apm.port]]"
        password: "[[ with .Service.redis_apm.user]][[.]]:[[end]][[.Service.redis_apm.pass]]"
        db: 0
        # Connection pool settings
        pool_size: 10
        dial_timeout: 5s
        read_timeout: 3s
        write_timeout: 3s
      
      # Example: Cluster mode
      # cluster:
      #   addrs:
      #     - "redis-node1:6379"
      #     - "redis-node2:6379"
      #     - "redis-node3:6379"
      #   password: ""
      
      # Example: Sentinel mode
      # sentinel:
      #   master_name: "mymaster"
      #   sentinel_addrs:
      #     - "sentinel1:26379"
      #     - "sentinel2:26379"
      #     - "sentinel3:26379"
      #   password: ""
    
    # Nacos connections
    nacos:
      default:
        server_addr: "[[.Service.nacos.host]]:[[.Service.nacos.port]]"
        namespace: ""  # Empty for default namespace
        username: "[[.Service.nacos.username]]"
        password: "[[.Service.nacos.password]]"
        timeout: 5s
        log_dir: "/tmp/nacos/log"
        cache_dir: "/tmp/nacos/cache"
        log_level: "warn"

  # Control plane extension - Agent interaction interface
  # Handles: Agent registration, heartbeat, task execution, status reporting
  controlplane:
    # Reference to storage extension for Redis/Nacos clients
    storage_extension: storage
    
    # Agent ID (auto-generated UUID if empty, or set via AGENT_ID env var)
    agent_id: ""
    
    # Agent registry configuration
    agent_registry:
      type: redis  # "memory" or "redis"
      redis_name: default  # Reference to redis connection name
      key_prefix: "otel:agents"
      # Instance info TTL (for historical queries, keeps agent info after going offline)
      instance_ttl: 24h
      # Heartbeat key TTL (for online detection, should be 2-3x heartbeat interval)
      # When heartbeat key expires, agent is marked as offline
      heartbeat_ttl: 60s
      # Offline detection interval
      offline_check_interval: 10s
      enable_events: true  # Enable Pub/Sub for agent events
      # Instance key mode: "host" (default) or "host_ip"
      # - "host": otel:agents:app/{appID}/svc/{svc}/host/{hostname}
      # - "host_ip": otel:agents:app/{appID}/svc/{svc}/host/{hostname}/ip/{ip}
      # Use "host_ip" when multiple instances run on the same host (e.g., containers)
      instance_key_mode: host
      # Enable hierarchy indexes for GetApps/GetServicesByApp/GetInstancesByService queries
      # When disabled, reduces Redis keys per agent
      enable_hierarchy_index: true
    
    # Task manager configuration
    task_manager:
      type: redis  # "memory" or "redis"
      redis_name: default
      key_prefix: "otel:tasks"
      result_ttl: 24h  # TTL for task results
      workers: 4
      queue_size: 100
      default_timeout: 30s
    
    # Config manager configuration
    # Use "on_demand" for dynamic multi-agent config management
    config_manager:
      type: on_demand  # "memory", "nacos", or "on_demand"
      nacos_name: default
      # on_demand mode settings (configs are loaded when agents connect)
      on_demand:
        namespace: ""
        load_timeout: 5s
        max_retries: 3
        retry_interval: 1s
        cache_expiration: 5m
        cleanup_interval: 1m
    
    # Local task executor configuration
    task_executor:
      workers: 4
      queue_size: 100
      default_timeout: 30s
    
    # Status reporter configuration
    status_reporter:
      completed_tasks_buffer: 50
      health_check_interval: 10s
    
    # Token manager for validating agent tokens
    # Shares the same backend as admin extension's token_manager
    token_manager:
      type: redis  # "memory" or "redis"
      redis_name: default
      key_prefix: "otel:apps"

  # Admin extension - Management HTTP API interface
  # Provides REST APIs for frontend management
  admin:
    # Reference to controlplane extension to reuse components
    # This avoids creating duplicate instances of ConfigManager, TaskManager, AgentRegistry, TokenManager
    # When set, the following component configs are ignored as they are reused from controlplane
    controlplane_extension: controlplane
    
    # HTTP server configuration
    http:
      endpoint: "0.0.0.0:8088"
      read_timeout: 30s
      write_timeout: 30s
      idle_timeout: 60s
    
    # CORS configuration
    cors:
      enabled: true
      allowed_origins:
        - "*"
      allowed_methods:
        - "GET"
        - "POST"
        - "PUT"
        - "DELETE"
        - "OPTIONS"
      allowed_headers:
        - "Authorization"
        - "Content-Type"
        - "X-API-Key"
      allow_credentials: false
      max_age: 86400
    
    # Authentication configuration
    auth:
      enabled: true
      type: api_key  # "basic", "jwt", or "api_key"
      
      # Basic auth configuration
      # basic:
      #   username: admin
      #   password: admin123
      
      # JWT auth configuration
      # jwt:
      #   secret: "your-jwt-secret-key"
      #   issuer: "otel-collector"
      #   audience: "admin-api"
      
      # API key auth configuration
      api_key:
        header: "X-API-Key"
        keys:
          - "your-api-key-1"
          - "your-api-key-2"
    
    # NOTE: The following component configs are only used when controlplane_extension is NOT set.
    # When controlplane_extension is set, these are ignored and components are reused from controlplane.
    #
    # # Agent registry (shares same backend as controlplane)
    # agent_registry:
    #   type: redis
    #   redis_name: default
    #   key_prefix: "otel:agents"
    #   heartbeat_ttl: 60s
    #   offline_check_interval: 10s
    #   enable_events: true
    # 
    # # Task manager (shares same backend as controlplane)
    # task_manager:
    #   type: redis
    #   redis_name: default
    #   key_prefix: "otel:tasks"
    #   result_ttl: 24h
    #   workers: 4
    #   queue_size: 100
    #   default_timeout: 30s
    # 
    # # Config manager (on_demand mode for multi-agent support)
    # config_manager:
    #   type: on_demand
    #   nacos_name: default
    #   on_demand:
    #     namespace: ""
    #     load_timeout: 5s
    #     max_retries: 3
    #     retry_interval: 1s
    #     cache_expiration: 5m
    #     cleanup_interval: 1m
    # 
    # # Token manager for app/token management
    # token_manager:
    #   type: redis
    #   redis_name: default
    #   key_prefix: "otel:apps"
    #   token_length: 32

    # Arthas tunnel extension reference (for browser WebSocket connections)
    # When set, admin will expose Arthas-related APIs:
    #   - GET /api/v1/arthas/agents           - List agents with Arthas connections
    #   - GET /api/v1/arthas/agents/{id}/status - Get agent Arthas status
    #   - GET /api/v1/arthas/ws               - Browser WebSocket endpoint
    arthas_tunnel_extension: arthas_tunnel

  # Arthas Tunnel extension - Remote Java debugging via WebSocket
  # Provides bidirectional WebSocket tunnel between browser and Java agent
  # Architecture:
  #   Browser <--WebSocket--> adminext <---> arthastunnelext <---> agentgatewayreceiver <--WebSocket--> Java Agent
  arthas_tunnel:
    # Maximum concurrent sessions per agent
    max_sessions_per_agent: 5
    # Session idle timeout (no activity)
    session_idle_timeout: 30m
    # Session maximum duration
    session_max_duration: 4h
    # Ping interval for WebSocket keepalive
    ping_interval: 30s
    # Pong response timeout
    pong_timeout: 10s
    # Output buffer size (bytes)
    output_buffer_size: 65536  # 64KB
    # Output flush interval
    output_flush_interval: 50ms

  # Memory limiter extension
  memory_limiter:
    check_interval: 1s
    limit_mib: 1024
    spike_limit_mib: 256

  # zPages for debugging
  zpages:
    endpoint: 0.0.0.0:55679

connectors:
  # Span metrics connector - generates RED metrics from traces
  # RED: Rate (request count), Errors, Duration
  spanmetrics:
    # Histogram configuration for latency metrics
    histogram:
      explicit:
        buckets: [5ms, 10ms, 25ms, 50ms, 100ms, 250ms, 500ms, 1s, 2.5s, 5s, 10s]
    # Dimensions to add as metric labels (from span attributes)
    dimensions:
      - name: http.method
        default: GET
      - name: http.status_code
      - name: http.route
      - name: rpc.method
      - name: rpc.service
    # Metrics flush interval
    metrics_flush_interval: 15s
    # Namespace for generated metrics
    namespace: traces.spanmetrics
    # Resource metrics key attributes
    resource_metrics_key_attributes:
      - service.name
      - service.namespace
      - deployment.environment

processors:
  # Batch processor for efficient data export
  batch:
    send_batch_size: 1000
    timeout: 10s
    send_batch_max_size: 1500

  # Memory limiter processor
  memory_limiter:
    check_interval: 1s
    limit_mib: 800
    spike_limit_mib: 200

  # Token auth processor - validates token from resource attributes
  # Use this for protocols that don't support HTTP headers (e.g., SkyWalking, Jaeger)
  # or when token is embedded in resource attributes
  tokenauth:
    # Resource attribute key to extract token from
    attribute_key: "token"
    # Action when token validation fails: "drop" or "pass"
    action: drop
    # Control plane extension name for token validation
    control_plane_extension: controlplane
    # Log dropped data due to invalid tokens
    log_dropped: true
    # Token validation cache configuration
    cache:
      enabled: true
      # TTL for valid token cache entries (seconds)
      # Valid tokens are cached longer for performance
      valid_ttl_seconds: 300  # 5 minutes
      # TTL for invalid token cache entries (seconds)
      # Shorter TTL allows quick recovery when tokens become valid
      invalid_ttl_seconds: 30  # 30 seconds
      # Maximum number of cache entries
      max_size: 10000
      # Background cleanup interval (seconds)
      cleanup_interval_seconds: 60

exporters:
  # Debug exporter for development
  debug:
    verbosity: detailed
    sampling_initial: 5
    sampling_thereafter: 200

  # OTLP HTTP exporter
  otlphttp/jaeger:
    endpoint: [[ .Service.otlp_jeager.url ]]


  # Prometheus Remote Write exporter for metrics
  prometheusremotewrite:
    endpoint: [[ .Service.prometheus_server.url ]]
    tls:
      insecure: true
    resource_to_telemetry_conversion:
      enabled: true

service:
  # Extensions load order: storage must be first (dependency for others)
  # arthas_tunnel must be before admin (admin depends on it)
  extensions: [storage, controlplane, arthas_tunnel, admin, memory_limiter, zpages]
  
  pipelines:
    traces:
      receivers: [agent_gateway]
      # tokenauth processor validates token from resource attributes
      # Place it before other processors for early rejection of invalid data
      processors: [tokenauth, memory_limiter, batch]
      exporters: [otlphttp/jaeger, spanmetrics]
    
    # Metrics from spanmetrics connector
    metrics/spanmetrics:
      receivers: [spanmetrics]
      processors: [batch]
      exporters: [prometheusremotewrite]
    
    metrics:
      receivers: [agent_gateway]
      processors: [tokenauth, memory_limiter, batch]
      exporters: [prometheusremotewrite]
    
    # logs:
    #   receivers: [enhanced_otlp]
    #   processors: [tokenauth, memory_limiter, batch]
    #   exporters: [debug]

  telemetry:
    logs:
      level: debug
      development: false  # Set to false to disable stack traces in warn logs
    metrics:
      level: detailed
      readers:
        - pull:
            exporter:
              prometheus:
                host: 0.0.0.0
                port: 8888
